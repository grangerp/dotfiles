#!/bin/bash

# Inspired greatly by Armin Ronacher's bashrc
# https://github.com/mitsuhiko/dotfiles/blob/master/bash/bashrc

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

export TERM=screen-256color


export PATH=~/bin:./node_modules/.bin:$HOME/.rvm/bin:/usr/local/share/npm/bin:/usr/local/go/bin:~/node_modules/.bin:~/pear/bin:~/.bin:/usr/local/bin:/usr/local/sbin:$HOME/Development/go/bin:/home/pgranger/.local/bin:$PATH

# Enable bash history
export HISTCONTROL=erasedups
export HISTSIZE=5000
shopt -s histappend

export FALLBACK_DYLD_LIBRARY_PATH=/usr/local/lib

# we always pass these to ls(1)
LS_COMMON="-hBG"

# setup the main ls alias if we've established common args
test -n "$LS_COMMON" &&
alias ls="command ls $LS_COMMON"

# These set up/down to do the history searching
bind '"\e[A"':history-search-backward
bind '"\e[B"':history-search-forward

alias ..='cd ..'

alias edit='$EDITOR $@'

alias glog="git log --graph --pretty=format:'%Cred%h%Creset %an: %s - %Creset %C(yellow)%d%Creset %Cgreen(%cr)%Creset' --abbrev-commit --date=relative"

function cleanswp() {
  find . -name "*.swp" -exec rm -rf {} \;

}
function cleanpycs() {
  find . -name "*.pyc" -exec rm -rf {} \;
}

# This will remove all *.pyc files and __pycache__ directories recursively in the current directory.
function claenpycache() {
  find . | grep -E "(__pycache__|\.pyc|\.pyo$)" | xargs rm -rf
}

function tfree() {
  top -l1 -s0 | head -n11
}

if [ -e "$HOME/.local-bashrc" ]; then
  source "$HOME/.local-bashrc"
fi

# Use git-completion if available
if [ -e "$HOME/.git-completion.bash" ]; then
  source "$HOME/.git-completion.bash"
fi;

# Use bash-completion, if available
if [ -f /etc/bash_completion ]; then
  . /etc/bash_completion
fi
if [ -f /usr/local/etc/bash_completion ]; then
  . /usr/local/etc/bash_completion
fi

# GRC support
if [ `uname` == "Darwin" ]; then
  grc_bash="`brew --prefix grc`/etc/grc.bashrc"
  if [ -e "$grc_bash" ]; then
    source "$grc_bash"
  fi;
fi;


[[ -s ~/.rvm/scripts/rvm ]] && source ~/.rvm/scripts/rvm  # This loads RVM into a shell session.


export PROMPT="$ "
export PS1=$PROMPT

function docker.clean_containers() {
    docker rm $(docker ps -a | grep -v Up | grep -v CONTAINER | cut -f 1 -d ' ')
}

function docker.clean_images() {
    docker rmi $(docker images | grep none | tr -s ' ' | cut -f 3 -d ' ')
}

function git.remove_untracked_remote_branch(){
    # fetch and prune remte
    # delete all local branch with no remote
    git fetch -p && git branch -vv | grep gone |gawk '{print $1}' | xargs git branch -d
}

function docker.clean_volumes(){
    docker volume rm $(docker volume ls -qf dangling=true)
}

function list_stashes(){
    # list stashes and if mounted or not
    echo -e "mounted\tstash"
    for STASH in $(gnome-encfs-manager list_stashes|gawk '{ print $1};')
    do
        local myres=$(gnome-encfs-manager is_mounted $STASH)
        echo -e "$myres\t$STASH"
    done
}

function git.stats.all(){
    echo `pwd`
    #ls -ld *|awk '{print "cd " $8 ";git st; cd .."}'|sh
}
alias git.fetch.all="ls -ld *|awk '{print \"cd \" $8 \";git fetch origin; cd ..\"}'|sh"
alias git.gc.all="ls -ld *|awk '{print \"cd \" $8 \";git gc; cd ..\"}'|sh"

export GPG_TTY=$(tty)

# pyenv
export PATH="/home/pgranger/.pyenv/bin:$PATH"
eval "$(pyenv init -)"
eval "$(pyenv virtualenv-init -)"

